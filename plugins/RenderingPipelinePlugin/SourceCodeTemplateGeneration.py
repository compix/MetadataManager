from PySide2 import QtWidgets
from RenderingPipelinePlugin import PipelineKeys
from RenderingPipelinePlugin.PipelineType import PipelineType
from RenderingPipelinePlugin.unreal_engine import UnrealEnginePipelineKeys

class Edit(object):
    def __init__(self) -> None:
        self.text = ""

    def append(self, text: str):
        self.text += text + "\n"

class SourceCodeTemplateSceneType:
    InputScene = 'InputScene'
    RenderScene = 'RenderScene'
    Compositing = 'Compositing'

def addCodeLine(edit: QtWidgets.QTextEdit, codeLine: str, tabs=0):
    edit.append(f'{" "*tabs*4}{codeLine}')

def generateNukeSourceCodeTemplate(edit: QtWidgets.QTextEdit, pipelineType: PipelineType):
    edit.clear()

    addCodeLine(edit, 'import nuke, os\n')

    addCodeLine(edit, 'class Environment:')
    addCodeLine(edit, '    def __init__(self, infoDict):')
    addCodeLine(edit, '        self.infoDict = infoDict\n')

    for key in [item for item in dir(PipelineKeys) if not item.startswith("__")]:
        value = getattr(PipelineKeys, key)

        addCodeLine(edit, f'    def {key}(self):')
        addCodeLine(edit, f'        return self.infoDict.get("{value}")')
        addCodeLine(edit, '')

    addCodeLine(edit, f'    def getRenderingFilename(self):')
    addCodeLine(edit, f'        return self.RenderingFilename().replace("\\\\", "/")\n')

    addCodeLine(edit, f'    def getPostOutputExtensions(self):')
    addCodeLine(edit, f'        return [ext.strip().lower() for ext in self.PostOutputExtensions().split(",")]\n')

    addCodeLine(edit, f'    def getPostFilename(self, ext):')
    addCodeLine(edit, f'        return self.PostFilename().replace("\\\\", "/") + "." + ext\n')

    addCodeLine(edit, '')
    addCodeLine(edit, 'def process(infoDict):')
    addCodeLine(edit, '    env = Environment(infoDict)\n')
    
    addCodeLine(edit,  '    # Set read node file:')
    addCodeLine(edit,  '    readNodeName = "Read"')
    addCodeLine(edit, f'    readNode = nuke.toNode(readNodeName)\n')
    addCodeLine(edit, f'    if not readNode:')
    addCodeLine(edit, f'        raise RuntimeError("Could not find " + readNodeName + " node.")\n')

    addCodeLine(edit, '    renderingFilename = env.getRenderingFilename()\n')

    if pipelineType == PipelineType.Blender:
        addCodeLine(edit, '    # Blender adds the frame number to the end of the file. Add it to the filename:')
        addCodeLine(edit, '    if not "#" in renderingFilename:')
        addCodeLine(edit, '        base, ext = os.path.splitext(renderingFilename)')
        addCodeLine(edit, '        renderingFilename = base + "0000" + ext')
        addCodeLine(edit, '')

    addCodeLine(edit, '    if not os.path.exists(renderingFilename):')
    addCodeLine(edit, '        raise RuntimeError("Could not find rendering " + renderingFilename)\n')

    addCodeLine(edit, f'    readNode["file"].setValue(renderingFilename)\n')

    # Setup write node:
    addCodeLine(edit, '    writeNodeName = "Write"')
    addCodeLine(edit, f'    writeNode = nuke.toNode(writeNodeName)\n')
    addCodeLine(edit, f'    if not writeNode:')
    addCodeLine(edit, f'        raise RuntimeError("Could not find " + writeNodeName + " node.")\n')

    addCodeLine(edit, '    # Set write node files:')
    addCodeLine(edit, f'    for ext in env.getPostOutputExtensions():')
    addCodeLine(edit, f'        filename = env.getPostFilename(ext)')
    addCodeLine(edit, f'        writeNode["file"].setValue(filename)\n')
    addCodeLine(edit, f'        nuke.execute(writeNode, 1, 1)')

def generateMaxSourceCodeTemplate(edit: QtWidgets.QTextEdit, sceneType: SourceCodeTemplateSceneType):
    edit.clear()
    
    addCodeLine(edit, 'global INFO_MAP = undefined')
    addCodeLine(edit, '')
    addCodeLine(edit, 'fn readInfoMap infoFile = (')
    addCodeLine(edit, '    py_main = Python.Import "__builtin__"')
    addCodeLine(edit, '    json = Python.Import "json"')
    addCodeLine(edit, '    ')
    addCodeLine(edit, '    f = py_main.open infoFile')
    addCodeLine(edit, '    infoMap = json.load f')
    addCodeLine(edit, '    f.close()')
    addCodeLine(edit, '    ')
    addCodeLine(edit, '    infoMap')
    addCodeLine(edit, ')')
    addCodeLine(edit, '')
    addCodeLine(edit, 'fn saveMaxFileChecked filename = (')
    addCodeLine(edit, '    if not (saveMaxFile filename) do throw ("Failed to save max file to " + filename as string)')
    addCodeLine(edit, ')')
    addCodeLine(edit, '')

    addCodeLine(edit, 'fn initInfoMapGlobals = (')
    for key in [item for item in dir(PipelineKeys) if not item.startswith("__")]:
        value = getattr(PipelineKeys, key)
        addCodeLine(edit, f'   global g_{key} = INFO_MAP["{value}"]')
    addCodeLine(edit, ')')
    
    addCodeLine(edit, '')
    addCodeLine(edit, 'fn executePipelineRequest infoFile = (')
    addCodeLine(edit, '    global INFO_MAP')
    addCodeLine(edit, '    ')
    addCodeLine(edit, '    INFO_MAP = readInfoMap infoFile')
    addCodeLine(edit, '    initInfoMapGlobals()')
    addCodeLine(edit, '    ')
    addCodeLine(edit, '    -- Prepare')
    addCodeLine(edit, '    loadedBaseSceneFile = loadMaxFile baseFile useFileUnits:true')
    addCodeLine(edit, '    if not loadedBaseSceneFile do throw ("Failed to load base scene file: " + g_BaseSceneFilename as string)')
    addCodeLine(edit, '    ')

    if sceneType == SourceCodeTemplateSceneType.RenderScene:
        addCodeLine(edit, '    -- Merge environment scene file if available')
        addCodeLine(edit, '    if g_EnvironmentSceneNaming != "" do (')
        addCodeLine(edit, '        mergedEnvSceneFile = mergeMAXFile g_EnvironmentSceneFilename #mergeDups #useMergedMtlDups #neverReparent')
        addCodeLine(edit, '        if not mergedEnvSceneFile do throw ("Failed to merge env scene file: " + g_EnvironmentSceneFilename as string)')
        addCodeLine(edit, '    )')
        addCodeLine(edit, '    ')

        addCodeLine(edit, '    -- Merge input scene file')
        addCodeLine(edit, '    mergedInputSceneFile = mergeMAXFile g_InputSceneFilename #mergeDups #useMergedMtlDups #neverReparent')
        addCodeLine(edit, '    if not mergedInputSceneFile do throw ("Failed to merge input scene file: " + g_InputSceneFilename as string)')
        addCodeLine(edit, '    ')

    addCodeLine(edit, '    /*******************************************************')
    addCodeLine(edit, '    TODO: Apply variation logic')
    addCodeLine(edit, '    ********************************************************/')
    addCodeLine(edit, '    ')
    addCodeLine(edit, f'    saveMaxFileChecked {"g_CreatedInputSceneFilename" if sceneType == SourceCodeTemplateSceneType.InputScene else "g_RenderSceneFilename"}')
    addCodeLine(edit, ')')

def generateBlenderSourceCodeTemplate(edit: QtWidgets.QTextEdit, sceneType: SourceCodeTemplateSceneType):
    edit.clear()

    addCodeLine(edit, 'import bpy, os\n')

    addCodeLine(edit, 'class Environment:')
    addCodeLine(edit, 'def __init__(self, infoDict: dict):', tabs=1)
    addCodeLine(edit, 'self.infoDict = infoDict\n', tabs=2)

    for key in [item for item in dir(PipelineKeys) if not item.startswith("__")]:
        value = getattr(PipelineKeys, key)
        if not isinstance(value, str):
            continue
        
        addCodeLine(edit, f'@property', tabs=1)
        addCodeLine(edit, f'def {key}(self):', tabs=1)
        addCodeLine(edit, f'return self.infoDict.get("{value}")', tabs=2)
        addCodeLine(edit, '')
    
    if sceneType != SourceCodeTemplateSceneType.Compositing:
        addCodeLine(edit, 'def mergeScene(filename: str):')
        addCodeLine(edit, '    if os.path.exists(filename):')
        addCodeLine(edit, '        with bpy.data.libraries.load(filename) as (dataFrom, _):')
        addCodeLine(edit, '            files = []')
        addCodeLine(edit, '            for c in dataFrom.collections:')
        addCodeLine(edit, '                files.append({"name" : c})')
        addCodeLine(edit, '')
        addCodeLine(edit, '            bpy.ops.wm.append(directory=os.path.join(filename, "Collection"), files=files)')
        addCodeLine(edit, '')
        addCodeLine(edit, 'def resetScene():')
        addCodeLine(edit, '    for collection in [col for col in bpy.data.collections]:')
        addCodeLine(edit, '        for obj in [obj for obj in collection.objects if obj.users > 0]:')
        addCodeLine(edit, '            bpy.data.objects.remove(obj)')
        addCodeLine(edit, '')
        addCodeLine(edit, '        bpy.data.collections.remove(collection)')

    if sceneType in [SourceCodeTemplateSceneType.RenderScene, SourceCodeTemplateSceneType.Compositing]:
        addCodeLine(edit, '')
        addCodeLine(edit, 'def frameCamera(cameraName: str):')
        addCodeLine(edit, '    camera = bpy.data.objects.get(cameraName)')
        addCodeLine(edit, '')
        addCodeLine(edit, '    if not camera:')
        addCodeLine(edit, '        raise RuntimeError(f"Could not find camera with name {cameraName}")')
        addCodeLine(edit, '')
        addCodeLine(edit, '    bpy.context.scene.camera = camera')
        addCodeLine(edit, '')
        addCodeLine(edit, '    # Select all visible objects:')
        addCodeLine(edit, '    for obj in bpy.data.objects:')
        addCodeLine(edit, '        if not obj.hide_render:')
        addCodeLine(edit, '            obj.select_set(True)')
        addCodeLine(edit, '')
        addCodeLine(edit, '    bpy.ops.view3d.camera_to_view_selected()')
        addCodeLine(edit, '')
        addCodeLine(edit, 'def imageFileFormatToExtension(fileFormat: str):')
        addCodeLine(edit, '    fileFormatToExtMap = {')
        addCodeLine(edit, '        "BMP": "bmp", ')
        addCodeLine(edit, '        "IRIS": "rgb", ')
        addCodeLine(edit, '        "PNG": "png", ')
        addCodeLine(edit, '        "JPEG": "jpg", ')
        addCodeLine(edit, '        "JPEG2000": "jp2",') 
        addCodeLine(edit, '        "TARGA": "tga", ')
        addCodeLine(edit, '        "TARGA_RAW": "tga", ')
        addCodeLine(edit, '        "CINEON": "cin", ')
        addCodeLine(edit, '        "DPX": "dpx", ')
        addCodeLine(edit, '        "OPEN_EXR_MULTILAYER": "exr", ')
        addCodeLine(edit, '        "OPEN_EXR": "exr",')
        addCodeLine(edit, '        "HDR": "hdr", ')
        addCodeLine(edit, '        "TIFF": "tif"')
        addCodeLine(edit, '    }')
        addCodeLine(edit, '')
        addCodeLine(edit, '    return fileFormatToExtMap.get(fileFormat)')
        addCodeLine(edit, '')
        addCodeLine(edit, 'def setRenderingOutputFilenames(env: Environment):')
        addCodeLine(edit, '    bpy.context.scene.render.filepath = env.RenderingFilename')
        addCodeLine(edit, '    compositorTree = bpy.context.scene.node_tree')
        addCodeLine(edit, '')
        addCodeLine(edit, '    if bpy.context.scene.use_nodes:')
        addCodeLine(edit, '        for node in compositorTree.nodes:')
        addCodeLine(edit, '            if node.type == "OUTPUT_FILE":')
        addCodeLine(edit, '                nodeFormat = node.format')
        addCodeLine(edit, '                if nodeFormat.file_format == "OPEN_EXR_MULTILAYER":')
        addCodeLine(edit, '                    node.base_path = env.PostFilename + ".exr"')
        addCodeLine(edit, '                else:')
        addCodeLine(edit, '                    node.base_path = os.path.dirname(env.PostFilename)')
        addCodeLine(edit, '                    for fileSlot in node.file_slots:')
        addCodeLine(edit, '                        if fileSlot.use_node_format:')
        addCodeLine(edit, '                            format = nodeFormat')
        addCodeLine(edit, '                        else:')
        addCodeLine(edit, '                            format = fileSlot.format')
        addCodeLine(edit, '')
        addCodeLine(edit, '                        ext = imageFileFormatToExtension(format.file_format)')
        addCodeLine(edit, '                        fileSlot.path = os.path.basename(env.PostFilename) + "." + ext')
        addCodeLine(edit, '')
        addCodeLine(edit, 'def renameOutputFiles(env: Environment):')
        addCodeLine(edit, '    """Blender adds the frame number to the end of the file. This function renames the files."""')
        addCodeLine(edit, '    compositorTree = bpy.context.scene.node_tree')
        addCodeLine(edit, '')
        addCodeLine(edit, '    for node in compositorTree.nodes:')
        addCodeLine(edit, '        if node.type == "OUTPUT_FILE":')
        addCodeLine(edit, '            nodeFormat = node.format')
        addCodeLine(edit, '            renameRequests = []')
        addCodeLine(edit, '            if nodeFormat == "OPEN_EXR_MULTILAYER":')
        addCodeLine(edit, '                renameRequests.append((f"{env.PostFilename}0001.exr", f"{env.PostFilename}.exr"))')
        addCodeLine(edit, '            else:')
        addCodeLine(edit, '                for fileSlot in node.file_slots:')
        addCodeLine(edit, '                    format = nodeFormat if fileSlot.use_node_format else fileSlot.format')
        addCodeLine(edit, '')
        addCodeLine(edit, '                    ext = imageFileFormatToExtension(format.file_format)')
        addCodeLine(edit, '                    renameRequests.append((f"{env.PostFilename}.{ext}0001", f"{env.PostFilename}.{ext}"))')
        addCodeLine(edit, '')
        addCodeLine(edit, '            for src, dst in renameRequests:')
        addCodeLine(edit, '                print(f"Replacing {src} with {dst}")')
        addCodeLine(edit, '')
        addCodeLine(edit, '                if os.path.exists(src):')
        addCodeLine(edit, '                    os.replace(src, dst)')
        addCodeLine(edit, '')
        addCodeLine(edit, 'def getFrames(env: Environment):')
        addCodeLine(edit, '    if not env.Frames:')
        addCodeLine(edit, '        return []')
        addCodeLine(edit, '')
        addCodeLine(edit, '    frameStrings = [f.strip() for f in env.Frames.split(",")]')
        addCodeLine(edit, '    frames = []')
        addCodeLine(edit, '    for f in frameStrings:')
        addCodeLine(edit, '        frameRange = f.split("-")')
        addCodeLine(edit, '        if len(frameRange) > 0:')
        addCodeLine(edit, '            start = int(frameRange[0].strip())')
        addCodeLine(edit, '            end = int(frameRange[1].strip())')
        addCodeLine(edit, '            frames += [i for i in range(start,end+1)]')
        addCodeLine(edit, '        else:')
        addCodeLine(edit, '            frames.append(int(f))')
        addCodeLine(edit, '    return frames')

    if sceneType == SourceCodeTemplateSceneType.Compositing:
        addCodeLine(edit, '')
        addCodeLine(edit, 'def replaceFramePlaceholder(name: str, frame: int):')
        addCodeLine(edit, '    start = name.find("#")')
        addCodeLine(edit, '    end = name.rfind("#") + 1')
        addCodeLine(edit, '')
        addCodeLine(edit, '    frameStr = str(frame)')
        addCodeLine(edit, '    count = len(frameStr)')
        addCodeLine(edit, '    needCount = end - start')
        addCodeLine(edit, '    for _ in range(needCount-count):')
        addCodeLine(edit, '        frameStr = "0" + frameStr')
        addCodeLine(edit, '')
        addCodeLine(edit, '    return name[:start] + frameStr + name[end:]')
        addCodeLine(edit, '')
        addCodeLine(edit, 'def getRenderingFilename(env: Environment, frame: int):')
        addCodeLine(edit, '    return replaceFramePlaceholder(env.RenderingFilename, frame)')

    addCodeLine(edit, '')
    addCodeLine(edit, 'def process(infoDict: dict):')
    addCodeLine(edit, '    """Entry point function for processing"""')
    addCodeLine(edit, '    env = Environment(infoDict)\n')

    # Always start with an empty scene if no base scene was provided:
    if sceneType != SourceCodeTemplateSceneType.Compositing:
        addCodeLine(edit, '    if not env.BaseSceneNaming:')
        addCodeLine(edit, '        print("Resetting scene...")\n')
        addCodeLine(edit, '        resetScene()\n')
    
    if sceneType == SourceCodeTemplateSceneType.RenderScene:
        addCodeLine(edit, '    # Merge environment scene file if available:')
        addCodeLine(edit, '    if env.EnvironmentSceneNaming:')
        addCodeLine(edit, '        print(f"Merging environment scene file: {env.EnvironmentSceneFilename}")')
        addCodeLine(edit, '        mergeScene(env.EnvironmentSceneFilename)\n')

        addCodeLine(edit, '    # Merge input scene file if available')
        addCodeLine(edit, '    if env.InputSceneNaming:')
        addCodeLine(edit, '        print(f"Merging input scene file: {env.InputSceneFilename}")')
        addCodeLine(edit, '        mergeScene(env.InputSceneFilename)\n')
        addCodeLine(edit, '')
        addCodeLine(edit, '    print("Setting rendering output filenames...")')
        addCodeLine(edit, '    setRenderingOutputFilenames(env)')
        addCodeLine(edit, '')

    if sceneType != SourceCodeTemplateSceneType.Compositing:
        addCodeLine(edit, '    print("Applying variation logic...")')

        addCodeLine(edit, '')
        addCodeLine(edit, '    # TODO: Apply variation logic')
        addCodeLine(edit, '')

    if sceneType == SourceCodeTemplateSceneType.RenderScene:
        addCodeLine(edit, '    if env.ApplyCameraFraming:')
        addCodeLine(edit, '        print("Framing to all visible objects...")')
        addCodeLine(edit, '        cameraName = f"Camera_{env.Perspective}" if env.Perspective else "Camera"')
        addCodeLine(edit, '        frameCamera(cameraName)')
        addCodeLine(edit, '')
    
        addCodeLine(edit, '    if env.SaveRenderScene:')
        addCodeLine(edit, '        print(f"Saving scene to {env.RenderSceneFilename}")')
        addCodeLine(edit, '        bpy.ops.wm.save_mainfile(filepath=env.RenderSceneFilename, check_existing=False)')
        addCodeLine(edit, '')
        addCodeLine(edit, '    if env.RenderInSceneCreationScript:')
        addCodeLine(edit, '        print("Rendering...")')
        addCodeLine(edit, '        frames = getFrames(env)')
        addCodeLine(edit, '        if len(frames) > 0:')
        addCodeLine(edit, '            for frame in frames:')
        addCodeLine(edit, '                print(f"Rendering frame {frame}...")')
        addCodeLine(edit, '                bpy.context.scene.frame_set(frame)')
        addCodeLine(edit, '                bpy.ops.render.render(write_still=True)')
        addCodeLine(edit, '        else:')
        addCodeLine(edit, '            bpy.ops.render.render(write_still=True)')
        addCodeLine(edit, '')
        addCodeLine(edit, '        if not "#" in env.RenderingFilename:')
        addCodeLine(edit, '            print("Renaming output files...")')
        addCodeLine(edit, '            renameOutputFiles(env)')
    elif sceneType == SourceCodeTemplateSceneType.InputScene:
        addCodeLine(edit, '    print(f"Saving scene to {env.CreatedInputSceneFilename}")')
        addCodeLine(edit, '    bpy.ops.wm.save_mainfile(filepath=env.CreatedInputSceneFilename, check_existing=False)')
    elif sceneType == SourceCodeTemplateSceneType.Compositing:
        addCodeLine(edit, '    bpy.context.scene.use_nodes = True')
        addCodeLine(edit, '    compositorTree = bpy.context.scene.node_tree')
        addCodeLine(edit, '    inputNode = compositorTree.nodes["Input"]')
        addCodeLine(edit, '')
        addCodeLine(edit, '    print("Setting rendering output filenames...")')
        addCodeLine(edit, '    setRenderingOutputFilenames(env)')
        addCodeLine(edit, '')
        addCodeLine(edit, '    print("Rendering...")')
        addCodeLine(edit, '    frames = getFrames(env)')
        addCodeLine(edit, '    if len(frames) > 0:')
        addCodeLine(edit, '        for frame in frames:')
        addCodeLine(edit, '            print(f"Rendering frame {frame}...")')
        addCodeLine(edit, '')
        addCodeLine(edit, '            renderingImage = bpy.data.images.load(getRenderingFilename(env, frame))')
        addCodeLine(edit, '            inputNode.image = renderingImage')
        addCodeLine(edit, '')
        addCodeLine(edit, '            bpy.context.scene.frame_set(frame)')
        addCodeLine(edit, '            bpy.ops.render.render()')
        addCodeLine(edit, '    else:')
        addCodeLine(edit, '        renderingFilename, ext = os.path.splitext(env.RenderingFilename)')
        addCodeLine(edit, '')
        addCodeLine(edit, '        # Handle the case where blender adds 0000 to the file')
        addCodeLine(edit, '        if not os.path.exists(env.RenderingFilename):')
        addCodeLine(edit, '            renderingFilename += "0000" + ext')
        addCodeLine(edit, '')
        addCodeLine(edit, '        renderingImage = bpy.data.images.load(renderingFilename)')
        addCodeLine(edit, '        inputNode.image = renderingImage')
        addCodeLine(edit, '        bpy.ops.render.render()')
        addCodeLine(edit, '')
        addCodeLine(edit, '    if not "#" in env.RenderingFilename:')
        addCodeLine(edit, '        print("Renaming output files...")')
        addCodeLine(edit, '        renameOutputFiles(env)')

def generateUnrealEngineEnvSettingsClasses(edit: QtWidgets.QTextEdit):
    addCodeLine(edit, 'class UnrealEnginePipelineSettings:')
    addCodeLine(edit, 'def __init__(self, infoDict: dict):', tabs=1)
    addCodeLine(edit, 'self.infoDict = infoDict\n', tabs=2)

    for key in [item for item in dir(UnrealEnginePipelineKeys) if not item.startswith("__")]:
        value = getattr(UnrealEnginePipelineKeys, key)
        if not isinstance(value, str):
            continue
        
        addCodeLine(edit, f'@property', tabs=1)
        addCodeLine(edit, f'def {key}(self):', tabs=1)
        addCodeLine(edit, f'return self.infoDict.get("{value}")', tabs=2)
        addCodeLine(edit, '')

    addCodeLine(edit, 'class Environment:')
    addCodeLine(edit, 'def __init__(self, infoDict: dict):', tabs=1)
    addCodeLine(edit, 'self.infoDict = infoDict\n', tabs=2)
    addCodeLine(edit, 'self.ueSettings = UnrealEnginePipelineSettings(infoDict)\n', tabs=2)

    for key in [item for item in dir(PipelineKeys) if not item.startswith("__")]:
        value = getattr(PipelineKeys, key)
        if not isinstance(value, str):
            continue
        
        addCodeLine(edit, f'@property', tabs=1)
        addCodeLine(edit, f'def {key}(self):', tabs=1)
        addCodeLine(edit, f'return self.infoDict.get("{value}")', tabs=2)
        addCodeLine(edit, '')

    addCodeLine(edit, f'@property', tabs=1)
    addCodeLine(edit, f'def UnrealEngine(self):', tabs=1)
    addCodeLine(edit, f'return self.ueSettings', tabs=2)
    addCodeLine(edit, '')

def generateUnrealEngineMoviePipelineExecutorCode():
    edit = Edit()
    addCodeLine(edit, 'import unreal, os, json, re')
    addCodeLine(edit, '')
    
    generateUnrealEngineEnvSettingsClasses(edit)

    addCodeLine(edit, '@unreal.uclass()')
    addCodeLine(edit, 'class MD_MoviePipelineExecutor(unreal.MoviePipelinePythonHostExecutor):')
    addCodeLine(edit, '    activeMoviePipeline = unreal.uproperty(unreal.MoviePipeline)')
    addCodeLine(edit, '    activeMoviePipelineQueue = unreal.uproperty(unreal.MoviePipelineQueue)')
    addCodeLine(edit, '    curJobIdx = unreal.uproperty(int)')
    addCodeLine(edit, '    totalJobCount = unreal.uproperty(int)')
    addCodeLine(edit, '')
    addCodeLine(edit, '    def _post_init(self):')
    addCodeLine(edit, '        self.activeMoviePipeline = None')
    addCodeLine(edit, '        self.activeMoviePipelineQueue = None')
    addCodeLine(edit, '        self.curJobIdx = 0')
    addCodeLine(edit, '        self.totalJobCount = 0')
    addCodeLine(edit, '        ')
    addCodeLine(edit, '    @unreal.ufunction(override=True)')
    addCodeLine(edit, '    def execute_delayed(self, inPipelineQueue: unreal.MoviePipelineQueue):')
    addCodeLine(edit, '        (cmdTokens, cmdSwitches, cmdParameters) = unreal.SystemLibrary.parse_command_line(unreal.SystemLibrary.get_command_line())')
    addCodeLine(edit, '        try:')
    addCodeLine(edit, '            descFile = cmdParameters["MD_DESC_FILE"]')
    addCodeLine(edit, '        except:')
    addCodeLine(edit, '            self.failJob("Missing \'-MD_DESC_FILE=...\' argument")')
    addCodeLine(edit, '            return')
    addCodeLine(edit, '')
    addCodeLine(edit, '        try:')
    addCodeLine(edit, '            with open(descFile) as f:')
    addCodeLine(edit, '                global ENV')
    addCodeLine(edit, '                ENV = Environment(json.load(f))')
    addCodeLine(edit, '        except Exception as e:')
    addCodeLine(edit, '            self.failJob(f"Failed to load desc file: {e}")')
    addCodeLine(edit, '            return')
    addCodeLine(edit, '')
    addCodeLine(edit, '        newQueue = unreal.MoviePipelineQueue()')
    addCodeLine(edit, '        newQueue.copy_from(inPipelineQueue)')
    addCodeLine(edit, '')
    addCodeLine(edit, '        self.activeMoviePipelineQueue = newQueue')
    addCodeLine(edit, '        jobs = inPipelineQueue.get_jobs()')
    addCodeLine(edit, '        self.totalJobCount = len(jobs)')
    addCodeLine(edit, '')
    addCodeLine(edit, '        if len(jobs) == 0:')
    addCodeLine(edit, '            self.failJob("The movie pipeline queue has no jobs.")')
    addCodeLine(edit, '            return')
    addCodeLine(edit, '')
    addCodeLine(edit, '        firstJob = jobs[0]')
    addCodeLine(edit, '        self.initAndRunJob(firstJob)')
    addCodeLine(edit, '')
    addCodeLine(edit, '    @unreal.ufunction(ret=None, params=[str])')
    addCodeLine(edit, '    def failJob(self, message: str):')
    addCodeLine(edit, '        unreal.log_error(message)')
    addCodeLine(edit, '        self.on_executor_errored()')
    addCodeLine(edit, '')
    addCodeLine(edit, '    @unreal.ufunction(override=True)')
    addCodeLine(edit, '    def on_begin_frame(self):')
    addCodeLine(edit, '        super(MD_MoviePipelineExecutor, self).on_begin_frame()')
    addCodeLine(edit, '        ')
    addCodeLine(edit, '        if self.activeMoviePipeline:')
    addCodeLine(edit, '            finishedJobCount = self.curJobIdx')
    addCodeLine(edit, '            progress = (unreal.MoviePipelineLibrary.get_completion_percentage(self.activeMoviePipeline) + finishedJobCount) / self.totalJobCount')
    addCodeLine(edit, '            unreal.log(f"PROGRESS: {progress}")')
    addCodeLine(edit, '')
    addCodeLine(edit, '    @unreal.ufunction(override=True)')
    addCodeLine(edit, '    def is_rendering(self):')
    addCodeLine(edit, '        return False')
    addCodeLine(edit, '        ')
    addCodeLine(edit, '    @unreal.ufunction(ret=None, params=[unreal.MoviePipelineExecutorJob])')
    addCodeLine(edit, '    def initJob(self, job: unreal.MoviePipelineExecutorJob):')
    addCodeLine(edit, '        config: unreal.MoviePipelineMasterConfig = job.get_configuration()')
    addCodeLine(edit, '        outputSetting: unreal.MoviePipelineOutputSetting = config.find_or_add_setting_by_class(unreal.MoviePipelineOutputSetting)')
    addCodeLine(edit, '        renderingName, renderingExt = os.path.splitext(os.path.basename(ENV.RenderingFilename))')
    addCodeLine(edit, '')
    addCodeLine(edit, '        if not ENV.UnrealEngine.KeepFileNameFormat:')
    addCodeLine(edit, '            frameIndicatorStartIdx = renderingName.find("#")')
    addCodeLine(edit, '            if frameIndicatorStartIdx >= 0:')
    addCodeLine(edit, '                frameIndicatorEndIdx = renderingName.rfind("#") + 1')
    addCodeLine(edit, '                count = frameIndicatorEndIdx - frameIndicatorStartIdx')
    addCodeLine(edit, '                outputSetting.zero_pad_frame_numbers = count')
    addCodeLine(edit, '')
    addCodeLine(edit, '            outputSetting.file_name_format = re.sub("#+", "{frame_number}", renderingName)')
    addCodeLine(edit, '')
    addCodeLine(edit, '        if len(renderingExt) < 2:')
    addCodeLine(edit, '            self.failJob(f"Invalid filename output extension: {renderingExt}")')
    addCodeLine(edit, '            return')
    addCodeLine(edit, '')
    addCodeLine(edit, '        fileExtToExtClass = {')
    addCodeLine(edit, '            "exr": unreal.MoviePipelineImageSequenceOutput_EXR,')
    addCodeLine(edit, '            "png": unreal.MoviePipelineImageSequenceOutput_PNG,')
    addCodeLine(edit, '            "jpg": unreal.MoviePipelineImageSequenceOutput_JPG')
    addCodeLine(edit, '        }')
    addCodeLine(edit, '')
    addCodeLine(edit, '        renderingExt = renderingExt[1:] # Remove the .')
    addCodeLine(edit, '        extClass = fileExtToExtClass.get(renderingExt)')
    addCodeLine(edit, '        if not extClass:')
    addCodeLine(edit, '            self.failJob(f"Unknown filename output extension: {renderingExt}")')
    addCodeLine(edit, '            return')
    addCodeLine(edit, '')
    addCodeLine(edit, '        # Remove the filename extension output settings that are not requested')
    addCodeLine(edit, '        if not ENV.UnrealEngine.KeepExtensionSettings:')
    addCodeLine(edit, '            for extClass_ in fileExtToExtClass.values():')
    addCodeLine(edit, '                if extClass_ != extClass:')
    addCodeLine(edit, '                    extSetting: unreal.MoviePipelineSetting = config.find_setting_by_class(extClass_)')
    addCodeLine(edit, '                    if extSetting:')
    addCodeLine(edit, '                        config.remove_setting(extSetting)')
    addCodeLine(edit, '')
    addCodeLine(edit, '        config.find_or_add_setting_by_class(extClass)')
    addCodeLine(edit, '        outputSetting.output_directory.path = os.path.dirname(ENV.RenderingFilename)')
    addCodeLine(edit, '')
    addCodeLine(edit, '        if ENV.RenderSceneNaming:')
    addCodeLine(edit, '            # SoftObjectPath requires the exact file in the package')
    addCodeLine(edit, '            basename = os.path.basename(ENV.RenderSceneFilename)')
    addCodeLine(edit, '            path = f"{ENV.RenderSceneFilename}.{basename}"')
    addCodeLine(edit, '            print(f"Setting map of the job: {path}")')
    addCodeLine(edit, '')
    addCodeLine(edit, '            job.map = unreal.SoftObjectPath(path)')
    addCodeLine(edit, '')
    addCodeLine(edit, '        config.initialize_transient_settings()')
    addCodeLine(edit, '')
    addCodeLine(edit, '    @unreal.ufunction(ret=None, params=[unreal.MoviePipelineExecutorJob])')
    addCodeLine(edit, '    def initAndRunJob(self, job: unreal.MoviePipelineExecutorJob):')
    addCodeLine(edit, '        self.initJob(job)')
    addCodeLine(edit, '')
    addCodeLine(edit, '        # Run')
    addCodeLine(edit, '        self.activeMoviePipeline: unreal.MoviePipeline = unreal.new_object(self.target_pipeline_class, outer=self.get_last_loaded_world(), base_type=unreal.MoviePipeline)')
    addCodeLine(edit, '        self.activeMoviePipeline.on_movie_pipeline_finished_delegate.add_function_unique(self, "onMoviePipelineFinished")')
    addCodeLine(edit, '        self.activeMoviePipeline.initialize(job)')
    addCodeLine(edit, '')
    addCodeLine(edit, '    @unreal.ufunction(ret=None, params=[unreal.MoviePipeline, bool])')
    addCodeLine(edit, '    def onMoviePipelineFinished(self, inMoviePipeline: unreal.MoviePipeline, bSuccess: bool):')
    addCodeLine(edit, '        self.curJobIdx += 1')
    addCodeLine(edit, '        jobs = self.activeMoviePipelineQueue.get_jobs()')
    addCodeLine(edit, '')
    addCodeLine(edit, '        if self.curJobIdx < len(jobs):')
    addCodeLine(edit, '            unreal.log("Starting next job...")')
    addCodeLine(edit, '            nextJob = jobs[self.curJobIdx]')
    addCodeLine(edit, '            self.initAndRunJob(nextJob)')
    addCodeLine(edit, '        else:')
    addCodeLine(edit, '            unreal.log("Finished rendering movie! Success: " + str(bSuccess))')
    addCodeLine(edit, '            self.activeMoviePipeline = None')
    addCodeLine(edit, '            self.on_executor_finished_impl()')
    addCodeLine(edit, '')
    addCodeLine(edit, '    @unreal.ufunction(override=True)')
    addCodeLine(edit, '    def on_map_load(self, inWorld):')
    addCodeLine(edit, '        pass')

    return edit.text

def generateUnrealEngineRenderingScript():
    edit = Edit()
    addCodeLine(edit, 'import unreal\n')
    generateUnrealEngineEnvSettingsClasses(edit)

    return edit.text

def generateUnrealEngineSourceCodeTemplate(edit: QtWidgets.QTextEdit, sceneType: SourceCodeTemplateSceneType):
    edit.clear()

    addCodeLine(edit, 'import unreal\n')

    generateUnrealEngineEnvSettingsClasses(edit)

    addCodeLine(edit, 'def findActorByName(name: str):')
    addCodeLine(edit, '    for a in unreal.EditorLevelLibrary.get_all_level_actors():')
    addCodeLine(edit, '        actor: unreal.Actor = a')
    addCodeLine(edit, '        if actor.get_name() == name:')
    addCodeLine(edit, '            return actor')
    addCodeLine(edit, '')
    addCodeLine(edit, '    return None')
    addCodeLine(edit, '')
    addCodeLine(edit, 'def process(infoDict: dict):')
    addCodeLine(edit, '    env = Environment(infoDict)')
    addCodeLine(edit, '    ')
    addCodeLine(edit, '    # Note: The UE scene filenames have no extension and may have paths to a level/map of a project.')
    addCodeLine(edit, '')
    addCodeLine(edit, '    # world = unreal.EditorLoadingAndSavingUtils.load_map(inputFilename)')
    addCodeLine(edit, '    world: unreal.World = unreal.EditorLoadingAndSavingUtils.new_blank_map(False)')
    addCodeLine(edit, '')
    addCodeLine(edit, '    #**************************************************')
    addCodeLine(edit, '    # TODO: Spawn actors')
    addCodeLine(edit, '    #**************************************************')
    addCodeLine(edit, '')
    addCodeLine(edit, '    #print("Spawning car...")')
    addCodeLine(edit, '    #car: unreal.StaticMeshActor = unreal.load_asset("/Game/ConceptCar/Car/SM_AutomotiveTP_Car")')
    addCodeLine(edit, '    #carActor: unreal.StaticMeshActor = unreal.EditorLevelLibrary.spawn_actor_from_object(car, unreal.Vector(0.0, 0.0, 0.0))')
    addCodeLine(edit, '    ')
    addCodeLine(edit, '    if not world:')
    addCodeLine(edit, '        raise RuntimeError("World could not be created.")')
    addCodeLine(edit, '')
    addCodeLine(edit, '    if env.BaseSceneNaming:')
    addCodeLine(edit, '        print(f"Adding level {env.BaseSceneFilename}...")')
    addCodeLine(edit, '        unreal.EditorLevelUtils.add_level_to_world(world, env.BaseSceneFilename, unreal.LevelStreamingAlwaysLoaded)')
    addCodeLine(edit, '')
    if sceneType == SourceCodeTemplateSceneType.RenderScene:
        addCodeLine(edit, '    if env.InputSceneNaming:')
        addCodeLine(edit, '        print(f"Adding level {env.InputSceneFilename}...")')
        addCodeLine(edit, '        unreal.EditorLevelUtils.add_level_to_world(world, env.InputSceneFilename, unreal.LevelStreamingAlwaysLoaded)')
        addCodeLine(edit, '')
        addCodeLine(edit, '    if env.EnvironmentSceneNaming:')
        addCodeLine(edit, '        print(f"Adding level {env.EnvironmentSceneFilename}...")')
        addCodeLine(edit, '        unreal.EditorLevelUtils.add_level_to_world(world, env.EnvironmentSceneFilename, unreal.LevelStreamingAlwaysLoaded)')
        addCodeLine(edit, '')
    addCodeLine(edit, '    #**************************************************')
    addCodeLine(edit, '    # TODO: Apply configuration')
    addCodeLine(edit, '    #**************************************************')
    addCodeLine(edit, '')
    addCodeLine(edit, '    # Note: Attaching actors across different levels is not possible')
    addCodeLine(edit, '    #turntableActor = findActorByName("BP_TurnTableSet_2")')
    addCodeLine(edit, '    #carActor.attach_to_actor(turntableActor, "", unreal.AttachmentRule.SNAP_TO_TARGET, unreal.AttachmentRule.SNAP_TO_TARGET, unreal.AttachmentRule.SNAP_TO_TARGET, False)')
    addCodeLine(edit, '')
    addCodeLine(edit, '    #print("Setting material...")')
    addCodeLine(edit, '    #materialPath = env.infoDict.get("Material")')
    addCodeLine(edit, '    #if materialPath:')
    addCodeLine(edit, '    #    staticMeshComponent: unreal.StaticMeshComponent = carActor.static_mesh_component')
    addCodeLine(edit, '    #    material = unreal.load_asset(materialPath)')
    addCodeLine(edit, '    #    staticMeshComponent.set_material(0, material)')
    addCodeLine(edit, '    ')
    if sceneType == SourceCodeTemplateSceneType.RenderScene:
        addCodeLine(edit, '    renderSceneFilename = env.RenderSceneFilename')
        addCodeLine(edit, '    print(f"Saving scene to {renderSceneFilename}...")')
        addCodeLine(edit, '    saved = unreal.EditorLoadingAndSavingUtils.save_map(world, renderSceneFilename)')
        addCodeLine(edit, '    if not saved:')
        addCodeLine(edit, '        raise RuntimeError(f"Failed to save scene to {renderSceneFilename}")')
    elif sceneType == SourceCodeTemplateSceneType.InputScene:
        addCodeLine(edit, '    createdSceneFilename = env.CreatedInputSceneFilename')
        addCodeLine(edit, '    print(f"Saving scene to {createdSceneFilename}...")')
        addCodeLine(edit, '    saved = unreal.EditorLoadingAndSavingUtils.save_map(world, createdSceneFilename)')
        addCodeLine(edit, '    if not saved:')
        addCodeLine(edit, '        raise RuntimeError(f"Failed to save scene to {createdSceneFilename}")')